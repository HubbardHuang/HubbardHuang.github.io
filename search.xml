<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/08/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2018/08/08/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<hr><p>title: C/C++ 函数调用原理<br>date: 2018-08-08 09:48:52<br>tags:<br>categories: 计算机底层</p><hr><p>在 C/C++ 函数调用的整个过程中内存空间进行了什么操作？本文对 C/C++ 函数调用原理进行扼要说明。<br><a id="more"></a></p><h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a><strong>一、预备知识</strong></h1><h2 id="一-内存中数据的地址"><a href="#一-内存中数据的地址" class="headerlink" title="(一) 内存中数据的地址"></a>(一) 内存中数据的地址</h2><p>地址在内存中存放时可能会跨越连续若干个存储单元（一个存储单元的大小为 1 个字节），而每个存储单元都有自己的编号，这个编号称为地址。机器规定以最小的编号作为该数据的地址。<br>请看以下代码和图 1。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8_t a = <span class="number">7</span><span class="comment">;</span></span><br><span class="line">uint16_t <span class="keyword">b </span>= <span class="number">500</span><span class="comment">;</span></span><br><span class="line">uint32_t c = <span class="number">1000</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><center><br><span style="color:gray">图 1. 内存中数据的地址</span><br><img src="http://pcny8g0ca.bkt.clouddn.com/%E5%86%85%E5%AD%98%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9C%B0%E5%9D%80.png" alt="内存中数据的地址"><br></center><br>变量 a 占据编号为 24 的内存单元，变量 b 占据编号为 25~26 的内存单元，变量 c 占据编号为 27~30 的内存单元。<br>依据约定，变量 a，b，c 的地址分别为 24，25，27。</p><h2 id="二-堆（Heap）和堆栈（Stack）"><a href="#二-堆（Heap）和堆栈（Stack）" class="headerlink" title="(二) 堆（Heap）和堆栈（Stack）"></a>(二) 堆（Heap）和堆栈（Stack）</h2><ol><li>堆栈亦称为栈，能够在函数运行之前自动分配足够的空间资源，函数运行完毕后自动回收资源。</li><li>堆的空间资源不同于栈，要获取它必须由程序员手动申请，然后由操作系统根据一定的算法进行分配。操作系统只有在进程结束时会自动回收该进程对应的堆空间资源，不过最好由程序员手动释放资源。<h2 id="三-代码段（Text-Section）"><a href="#三-代码段（Text-Section）" class="headerlink" title="(三) 代码段（Text Section）"></a>(三) 代码段（Text Section）</h2>每个函数经过编译生成的二进制机器指令皆存储在内存空间中的代码段。<h2 id="四-栈帧（Stack-Frame）"><a href="#四-栈帧（Stack-Frame）" class="headerlink" title="(四) 栈帧（Stack Frame）"></a>(四) 栈帧（Stack Frame）</h2>上文提到，栈能够为函数运行分配足够的空间资源，这种资源便称为栈帧。</li><li>栈帧的分配是从高地址向低地址逐步执行的。</li><li>一个栈帧大小不是无限的，其最靠近低地址的一端称为栈顶，最接近高地址的一端称为栈底，<br>栈顶地址和栈底地址各自保存在专门的寄存器里边，这两个专门的寄存器存放的值都是地址，故亦可分别称之为<font color="red">栈顶指针</font>、<font color="red">栈底指针</font>。<br>一个栈帧栈底地址减去栈顶地址所得的值决定了该栈帧的大小，可以通过让栈顶指针自增与自减分别控制栈帧的缩小与扩大。</li><li><p>一个函数栈帧的结构如图 2 所示（下文会提到返回地址），假设该函数局部变量个数不为 0，且有调用其他函数。<br><center><br><span style="color:gray">图 2. 单个函数栈帧的结构</span><br><img src="http://pcny8g0ca.bkt.clouddn.com/%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="单个函数栈帧的结构"><br></center></p><h2 id="五-堆栈指针寄存器和基址指针寄存器"><a href="#五-堆栈指针寄存器和基址指针寄存器" class="headerlink" title="(五) 堆栈指针寄存器和基址指针寄存器"></a>(五) 堆栈指针寄存器和基址指针寄存器</h2><p>堆栈指针寄存器和基址指针寄存器都属于通用寄存器。</p></li><li><p>堆栈指针寄存器用来存放栈帧的栈顶地址，根据数据位数不同可以分为三种，16位的 sp，32位的 esp，64位的 rsp，为说明方便，下文以 esp 为例进行阐述。</p></li><li><p>基址指针寄存器用来存放栈帧的栈底地址，根据数据位数不同可以分为三种，16位的 bp，32位的 ebp，64位的 rbp，为说明方便，下文以 ebp 为例进行阐述。</p><h2 id="六-指令寄存器-ip"><a href="#六-指令寄存器-ip" class="headerlink" title="(六) 指令寄存器 ip"></a>(六) 指令寄存器 ip</h2><p>该寄存器总是存放<font color="red">下一条</font>执行指令的所在地址。</p><h2 id="七-入栈指令-push-和出栈指令-pop"><a href="#七-入栈指令-push-和出栈指令-pop" class="headerlink" title="(七) 入栈指令 push 和出栈指令 pop"></a>(七) 入栈指令 push 和出栈指令 pop</h2><p>push 和 pop 都属于汇编指令。</p></li><li><p>入栈操作分为两步。第一步栈顶指针自减以扩大栈帧空间；第二步，将某个寄存器的值保存新开辟的位置上。</p></li><li>出栈操作只有一步。第一步，栈顶指针自增以缩小栈帧空间，将原先最靠近栈顶的值赋予某个寄存器。</li><li><p>如图 3 所示。<br><center><br><span style="color:gray">图 3. 入栈指令 push 和出栈指令 pop</span><br><img src="http://pcny8g0ca.bkt.clouddn.com/%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4%20push%20%E5%92%8C%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4%20pop.png" alt="入栈指令 push 和出栈指令 pop"><br></center></p><h2 id="八-函数调用指令-call"><a href="#八-函数调用指令-call" class="headerlink" title="(八) 函数调用指令 call"></a>(八) 函数调用指令 call</h2><p>call 也属于汇编指令。</p></li><li><p>调用一个函数时，一定会执行 call 指令，汇编中调用 printf 函数的写法如下。</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> <span class="built_in">printf</span></span><br></pre></td></tr></table></figure></li><li><p>call 指令包括两个步骤，第一步是让当前指令寄存器 ip 的值入栈，作为<font color="red">返回地址</font>，第二步是将指令寄存器 ip 的值修改为接下来即将调用的函数第一条机器指令的所在地址，从而实现跳转。</p><h2 id="九-函数参数入栈顺序"><a href="#九-函数参数入栈顺序" class="headerlink" title="(九) 函数参数入栈顺序"></a>(九) 函数参数入栈顺序</h2><p>函数参数入栈顺序为从右到左。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="number">1</span>, <span class="string">'A'</span>, <span class="number">3.14</span>)</span>;</span></span><br></pre></td></tr></table></figure></li></ol><p>该函数参数入栈顺序为 <code>3.14</code>，<code>&#39;A&#39;</code>，<code>1</code>。</p><h2 id="十-不同函数的机器指令段的共性"><a href="#十-不同函数的机器指令段的共性" class="headerlink" title="(十) 不同函数的机器指令段的共性"></a>(十) 不同函数的机器指令段的共性</h2><p>每个函数的机器指令段的开头，都有以下几步操作：</p><ol><li>第一步，在栈帧中保存上一栈帧的栈底地址，汇编指令为 <code>push ebp</code>。</li><li>第二步，将上一栈帧的栈顶地址作为当前函数栈帧的栈底地址，汇编指令为 <code>mov ebp, esp</code>。</li><li>第三步，为当前函数的局部变量开辟足够的空间，汇编指令为 <code>sub esp, M</code>，M 为局部变量占用栈帧空间的字节数。</li></ol><p>每个函数的机器指令段的末尾，都有以下几步操作：</p><ol><li>第一步，将 esp 恢复为为局部变量开辟空间之前的值，汇编指令为 <code>mov esp, ebp</code>，恢复后，esp 的值恰好是上一栈帧栈底地址的地址。</li><li>第二步，将 ebp 恢复为上一栈帧的栈底地址，汇编指令为 <code>mov ebp, $esp</code>，恢复后，esp 的值恰好是存放返回地址的地址。</li><li>第三步，将 eip 恢复为 call 指令第一步骤所操作的值，汇编指令为 <code>mov eip, $esp</code>，恢复后，esp 的值恰好为刚执行完的函数的第一个形参的入栈地址。</li><li>第四步，将 esp 值恢复为为刚执行完的函数的参数开辟空间之前的值，汇编指令为 <code>pop ...(arg)</code>，恢复后，esp 的值恰好是当前栈帧最靠近 0 地址的局部变量的地址。</li></ol><hr><h1 id="二、C-C-函数调用过程剖解"><a href="#二、C-C-函数调用过程剖解" class="headerlink" title="二、C/C++ 函数调用过程剖解"></a>二、C/C++ 函数调用过程剖解</h1><p>以下列程序为例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> apple = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> pear = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"apple = %d, pear = %d.\n"</span>, apple, pear);</span><br><span class="line">    total = apple + pear;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><code>printf</code> 函数调用之前，参数从右向左入栈。</li><li>调用 call 指令，此时存储在指令寄存器 ip 中的值是 <code>printf</code> 函数下一条语句 <code>total = apple + pear;</code> 对应的机器指令的地址，该地址入栈，同时指令寄存器 ip 的值修改为 <code>printf</code> 函数在代码段中的第一条指令的地址。</li><li>根据“一、(十)”可知，开始执行 <code>printf</code> 函数时，会进行三步操作——在 <code>printf</code> 函数栈帧中保存 <code>main</code> 函数栈帧的栈底地址；将 <code>main</code> 函数栈帧的栈顶地址作为 <code>printf</code> 函数栈帧的栈底地址；为 <code>printf</code> 函数的局部变量开辟足够的空间。三步操作执行完之后便开始执行 <code>printf</code> 函数的主体机器指令段。</li><li>根据“一、(十)”可知，<code>printf</code> 函数的主体机器指令段执行完毕后，便开始收尾工作——将 esp 恢复为为 <code>printf</code> 函数局部变量开辟空间之前的值；将 ebp 恢复为 <code>main</code> 函数栈帧的栈底地址；将 eip 恢复为语句 <code>total = apple + pear;</code> 对应的机器指令地址；将 esp 值恢复为为 <code>printf</code> 函数的参数开辟空间之前的值，恢复后，esp 的值恰好是 <code>total</code> 的地址。</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hexo 使用 mathJax</title>
      <link href="/2018/07/29/Hexo%20%E4%BD%BF%E7%94%A8%20mathJax/"/>
      <url>/2018/07/29/Hexo%20%E4%BD%BF%E7%94%A8%20mathJax/</url>
      <content type="html"><![CDATA[<p>原生的 Hexo 并不支持数学公式，需要安装一款名为 mathJax 插件才能让我们在博客中嵌入数学公式。<br><a id="more"></a></p><h1 id="一、安装与配置"><a href="#一、安装与配置" class="headerlink" title="一、安装与配置"></a><strong>一、安装与配置</strong></h1><ol><li>在 Bash 中输入命令 <code>npm install hexo-math --save</code>。</li><li><p>在站点配置文件 _config.yml 中添加以下代码。</p> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">math</span>:</span><br><span class="line"><span class="attribute">engine</span>: <span class="string">'mathjax'</span> # or <span class="string">'katex'</span></span><br><span class="line"><span class="attribute">mathjax</span>:</span><br><span class="line"># <span class="attribute">src</span>: custom_mathjax_source</span><br><span class="line"><span class="attribute">config</span>:</span><br><span class="line">  # MathJax config</span><br></pre></td></tr></table></figure><p> 在主题配置文件中 themes/next/_config.yml 中将 mathJax 下面的 enable 值设为 true。</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="二、重新部署"><a href="#二、重新部署" class="headerlink" title="二、重新部署"></a><strong>二、重新部署</strong></h1><p>在 Bash 中输入命令 <code>hexo g -d</code>。</p><hr><h1 id="三、本文参考资料链接"><a href="#三、本文参考资料链接" class="headerlink" title="三、本文参考资料链接"></a><strong>三、本文参考资料链接</strong></h1><p><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">http://stevenshi.me/2017/06/26/hexo-insert-formula/</a></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ext2 文件系统初探</title>
      <link href="/2018/07/29/Ext2%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/07/29/Ext2%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>文件系统是在存储设备上组织文件的方法。Ext2 文件系统是 Linux 操作系统流行的文件系统之一。<br><a id="more"></a></p><h1 id="一、扇区管理"><a href="#一、扇区管理" class="headerlink" title="一、扇区管理"></a><strong>一、扇区管理</strong></h1><p>磁盘上的一个扇区存储空间一般为 512B，但扇区的管理通常不是以扇区为单位，而是将若干个扇区合并成一个管理单元，作为读写文件的基本单位，大小一般为 $2^n$ 个扇区（$n \in Z,n &gt; 0$）。这个基本单位，在 Windows 系统中称为<strong>簇（clust）</strong>，在Linux系统中称为<strong>块（block）</strong>。</p><hr><h1 id="二、block-与-block-group"><a href="#二、block-与-block-group" class="headerlink" title="二、block 与 block group"></a><strong>二、block 与 block group</strong></h1><ol><li>一个 Ext2 文件系统中每个block的大小都是一样的，一般为 1024B 或 4096B。block 的大小在创建文件系统时被决定。</li><li>若干个 block 组成一个 block group，一个 block group 有多少个 block 是固定的。</li></ol><hr><h1 id="三、Ext2-文件系统布局"><a href="#三、Ext2-文件系统布局" class="headerlink" title="三、Ext2 文件系统布局"></a><strong>三、Ext2 文件系统布局</strong></h1><h2 id="一-磁盘内总体布局"><a href="#一-磁盘内总体布局" class="headerlink" title="(一) 磁盘内总体布局"></a>(一) 磁盘内总体布局</h2><p><center><br><span style="color:gray">图 1. Ext2 文件系统磁盘内总体布局</span><br><img src="http://pcny8g0ca.bkt.clouddn.com/Ext2%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E5%86%85%E6%80%BB%E4%BD%93%E5%B8%83%E5%B1%80.png" alt="Ext2 文件系统磁盘内总体布局"><br></center></p><h2 id="二-块组内布局及模块简介"><a href="#二-块组内布局及模块简介" class="headerlink" title="(二) 块组内布局及模块简介"></a>(二) 块组内布局及模块简介</h2><p><center><br><span style="color:gray">图 2. Ext2 文件系统块组内布局</span><br><img src="http://pcny8g0ca.bkt.clouddn.com/Ext2%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9D%97%E7%BB%84%E5%86%85%E5%B8%83%E5%B1%80.png" alt="Ext2 文件系统块组内布局"><br></center></p><p><center><br><span style="color:gray">图 3. Ext2 文件系统块组内布局模块简介</span><br><img src="http://pcny8g0ca.bkt.clouddn.com/Ext2%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9D%97%E7%BB%84%E5%86%85%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B.png" alt="Ext2 文件系统块组内布局模块简介"><br></center></p><h2 id="三-对-super-block-和-GDT-的特别说明"><a href="#三-对-super-block-和-GDT-的特别说明" class="headerlink" title="(三) 对 super block 和 GDT 的特别说明"></a>(三) 对 super block 和 GDT 的特别说明</h2><ol><li>每个 block group 中的 super block 和 GDT 都相同，前者记录整个文件系统的管理信息；后者记录每个块组的描述符。</li><li>文件系统启动时，只有第一个 block group 中的 super block 和 GDT 被读取到内存，其他块组中的数据作为冗余备份。</li></ol><hr><h1 id="四、参考资料链接"><a href="#四、参考资料链接" class="headerlink" title="四、参考资料链接"></a><strong>四、参考资料链接</strong></h1><p><a href="https://blog.csdn.net/Scotfield_msn/article/details/52598020" target="_blank" rel="noopener">https://blog.csdn.net/Scotfield_msn/article/details/52598020</a><br><a href="https://blog.csdn.net/djy37010/article/details/50485325" target="_blank" rel="noopener">https://blog.csdn.net/djy37010/article/details/50485325</a></p>]]></content>
      
      <categories>
          
          <category> 计算机底层 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于deb包</title>
      <link href="/2018/07/23/%E5%85%B3%E4%BA%8Edeb%E5%8C%85/"/>
      <url>/2018/07/23/%E5%85%B3%E4%BA%8Edeb%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>如果一个要安装的软件包是deb包，那么它的安装和删除操作将会十分简单，两者都只需要通过运行一条dpkg命令即可完成。<br><a id="more"></a></p><h1 id="一、用checkinstall将源码转换成deb包"><a href="#一、用checkinstall将源码转换成deb包" class="headerlink" title="一、用checkinstall将源码转换成deb包"></a>一、用checkinstall将源码转换成deb包</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./configure</span></span><br><span class="line">make</span><br><span class="line">sudo checkinstall</span><br><span class="line"><span class="string">...</span><span class="params">(根据提示操作)</span></span><br></pre></td></tr></table></figure><h1 id="二、用dpkg命令管理deb包"><a href="#二、用dpkg命令管理deb包" class="headerlink" title="二、用dpkg命令管理deb包"></a>二、用dpkg命令管理deb包</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i <span class="keyword">package</span>.deb         <span class="meta">#安装包</span></span><br><span class="line">dpkg -r <span class="keyword">package</span>             <span class="meta">#删除包</span></span><br><span class="line">dpkg -P <span class="keyword">package</span>             <span class="meta">#删除包（包括配置文件）</span></span><br><span class="line">dpkg -L <span class="keyword">package</span>             <span class="meta">#列出与该包关联的文件及其路径</span></span><br><span class="line">dpkg -l <span class="keyword">package</span>             <span class="meta">#显示该包的版本</span></span><br><span class="line">dpkg --unpack <span class="keyword">package</span>.deb   <span class="meta">#解开deb包的内容</span></span><br><span class="line">dpkg -S keyword             <span class="meta">#搜索所属的包内容</span></span><br><span class="line">dpkg -l                     <span class="meta">#列出当前已安装的包</span></span><br><span class="line">dpkg -c <span class="keyword">package</span>.deb         <span class="meta">#列出deb包的内容</span></span><br><span class="line">dpkg --configure <span class="keyword">package</span>    <span class="meta">#配置包</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux操作 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
